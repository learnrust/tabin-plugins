initSidebarItems({"fn":[["structopt","Generates the `StructOpt` impl."]],"macro":[["Token","A type-macro that expands to the name of the Rust type representation of a given token."],["alt","Run a series of parsers, returning the result of the first one which succeeds."],["braces","Parse inside of `{` `}` curly braces."],["brackets","Parse inside of `[` `]` square brackets."],["call","Invoke the given parser function with zero or more arguments."],["cond","Execute a parser only if a condition is met, otherwise return None."],["cond_reduce","Execute a parser only if a condition is met, otherwise fail to parse."],["do_parse","Run a series of parsers, optionally naming each intermediate result, followed by a step to combine the intermediate results."],["epsilon","Parses nothing and always succeeds."],["input_end","Parse nothing and succeed only if the end of the enclosing block has been reached."],["keyword","Parse a single Rust keyword token."],["many0","Parse zero or more values using the given parser."],["map","Transform the result of a parser by applying a function or closure."],["named","Define a parser function with the signature expected by syn parser combinators."],["not","Invert the result of a parser by parsing successfully if the given parser fails to parse and vice versa."],["option","Turn a failed parse into `None` and a successful parse into `Some`."],["parens","Parse inside of `(` `)` parentheses."],["parse_quote","Quasi-quotation macro that accepts input like the [`quote!`] macro but uses type inference to figure out a return type for those tokens."],["punct","Parse a single Rust punctuation token."],["reject","Unconditionally fail to parse anything."],["switch","Pattern-match the result of a parser to select which other parser to run."],["syn","Parse any type that implements the `Synom` trait."],["tuple","Run a series of parsers and produce all of the results in a tuple."],["value","Produce the given value without parsing anything."]]});